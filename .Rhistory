download.file("https://www.bfs.admin.ch/bfsstatic/dam/assets/15864476/master",destfile=destfile2)
# 1. communal area data
df<-read.xlsx(destfile,1,startRow=6,header=T) %>% janitor::clean_names()
year_value<-df$gesamtflache_in_km_1[1]
df<-df[3:nrow(df),]
df$gemeindecode[1]<-0
head(df)
year_value
new_df<-df[,c("gesamtflache_in_km_1","gemeindecode")]
head(new_df)
colnames(new_df)[colnames(new_df)=="gesamtflache_in_km_1"]<-"value"
colnames(new_df)[colnames(new_df)=="gemeindecode"]<-"spatialunit_id"
new_df$time_value<-year_value
# 2. cantonal area data
df2<-read.xlsx(destfile2,1,startRow=36,header=T) %>% janitor::clean_names()
df2<-df2[1,]
head(df2)
#check
if(substr(df2[1,1],1,12)!="Fläche in km") stop("Error: Excel-File seems not to be OK")
year_value<-as.numeric(df2[1,2])
df2<-df2[,4:29]
df2<-as.data.frame(t(df2))
colnames(df2)<-c("value")
df2$spatialunit_id<-seq(10000,260000,by=10000)
df2$time_value<-year_value
head(df2)
head(new_df)
head(df2)
new_df<-bring_indicator_values_to_order(new_df)
df2<-bring_indicator_values_to_order(df2)
new_df<-rbind(new_df,df2)
new_df$indicator_id<-32001
new_df$timeinfo_id<-1
head(new_df)
new_df<-fill_dimensions_with_na(new_df,value_id=TRUE)
head(new_df)
new_df<-bring_indicator_values_to_order(new_df,final_length=T)
# Main-Script - see also readme
# preparation of some global constants
src_folder<-"src/"
log_folder<-"log/"
datetime<-format(Sys.time(), "%Y-%m-%d_%H-%M")
flag_force_update<-TRUE
# temporary work_around
source("statbot_read_px.R")
# function to quicker log some output
logger<-function(log_string){
cat(log_string,sep = "\n",file=paste0(log_folder,"main_",datetime,".log"),append=TRUE)
}
# get the name of all the files in the src-folder
logger("STARTING STATBOT DATA MANAGEMENT...")
logger("LOADING SRC FILES...")
files.sources<-paste0(src_folder,list.files(src_folder))
# separate R and python scripts
logger("SEPARATING SRC FILES...")
r.sources<-NULL
python.sources<-NULL
for(i in files.sources){
if(substr(i,nchar(i)-1,nchar(i))==".R"){
r.sources<-c(r.sources,i)
}else{
if(substr(i,nchar(i)-2,nchar(i))==".py"){
python.sources<-c(python.sources,i)}
else{
logger("Error: Some Files are neither .R nor .py")
stop("Stopping the execution")
}
}
}
# Cleaning/Removing all the previous R-functions starting with statbot_src_ in case that they are still in memory
rm(list=ls(pat="statbot_src_"))
# source all the R-files
sapply(r.sources, source)
source("init_scripts/create_spatial_units_v2.R")
create_spatial_units()
# R-loop: execute all sourced functions statbot_src_XXX
logger("STARTING R-LOOP...")
for(i in lsf.str()){
start_time<-Sys.time()
if(substr(i,1,12)=="statbot_src_"){
print(paste0("Executing script... ",i))
return_value<-tryCatch(do.call(i,args=list(flag_force_update=flag_force_update)),
error=function(c) paste0("error loading r-script: ",c),
warning=function(c) paste0("warning loading r-script: ",c),
message=function(c) paste0("message loading r-script: ",c))
end_time<-Sys.time()
logger(paste0(
substr(i,13,nchar(i)),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
}
# python-loop: execute all sourced python files directly
logger("STARTING PYTHON-LOOP...")
for(i in python.sources){
start_time<-Sys.time()
print(paste0("Executing script... ",i))
return_value<-tryCatch(system(paste0("python ",i)),
error=function(c) paste0("error loading python-script: ",c),
warning=function(c) paste0("warning loading python-script: ",c),
message=function(c) paste0("message loading python-script: ",c))
#TODO: THE PYTHON PART STILL NEEDS A UP-TO-DATE CODE AND HASH-TEST
return_value<-ifelse(return_value==0,"UPDATE OK","ERROR")
end_time<-Sys.time()
logger(paste0(
substr(i,as.integer(gregexpr(pattern ='/',i)[[1]])+1,nchar(i)-3),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
logger("FINISHED MAIN-SCRIPT.")
destfile<-"temp/bfs_gp.xlsx"
destfile2<-"temp/bfs_kantone.xlsx"
# 1. communal area data
df<-read.xlsx(destfile,1,startRow=6,header=T) %>% janitor::clean_names()
# 2. cantonal area data
df2<-read.xlsx(destfile2,1,startRow=36,header=T) %>% janitor::clean_names()
df<-read.xlsx(destfile,1,startRow=6,header=T) %>% janitor::clean_names()
year_value<-df$gesamtflache_in_km_1[1]
df<-df[3:nrow(df),]
df$gemeindecode[1]<-0
new_df<-df[,c("gesamtflache_in_km_1","gemeindecode")]
colnames(new_df)[colnames(new_df)=="gesamtflache_in_km_1"]<-"value"
colnames(new_df)[colnames(new_df)=="gemeindecode"]<-"spatialunit_id"
new_df$time_value<-year_value
# 2. cantonal area data
df2<-read.xlsx(destfile2,1,startRow=36,header=T) %>% janitor::clean_names()
df2<-df2[1,]
#check
if(substr(df2[1,1],1,12)!="Fläche in km") stop("Error: Excel-File seems not to be OK")
year_value<-as.numeric(df2[1,2])
df2<-df2[,4:29]
df2<-as.data.frame(t(df2))
colnames(df2)<-c("value")
df2$spatialunit_id<-seq(10000,260000,by=10000)
df2$time_value<-year_value
new_df<-bring_indicator_values_to_order(new_df)
df2<-bring_indicator_values_to_order(df2)
new_df<-rbind(new_df,df2)
new_df$indicator_id<-32001
new_df$timeinfo_id<-1
new_df<-fill_dimensions_with_na(new_df,value_id=TRUE)
new_df<-bring_indicator_values_to_order(new_df,final_length=T)
write.csv(new_df,"data/values/32001_CH.csv",row.names = F)
update_last_updated(32001)
df<-read.csv("data/indicators.csv")
source("helper.R")
# Cleaning/Removing all the previous variables starting with statbot_ind_ in case that they are still in memory
rm(list=ls(pat="statbot_ind_"))
statbot_ind_11001<-data.frame(indicator_id=11001,name_de="Ständige Wohnbevölkerung",name_fr="Ständige Wohnbevölkerung",
name_it="Ständige Wohnbevölkerung",name_en="Ständige Wohnbevölkerung",
description_de="Ständige Bevölkerung",description_fr="Ständige Bevölkerung",
description_it="Ständige Bevölkerung",description_en="Ständige Bevölkerung",
unit_short_de="Pers.",unit_short_fr="Pers.",unit_short_it="Pers.",unit_short_en="Pers.",
unit_long_de="Personen",unit_long_fr="Personen",unit_long_it="Personen",unit_long_en="Personen",
source="BFS-STATPOP",dim1_id=1,dim2_id=2,dim3_id=3,dim4_id=NA,last_updated=NA,min_year=2010,max_year=2020)
statbot_ind_11101<-data.frame(indicator_id=11101,name_de="Geburten",name_fr="Geburten",
name_it="Geburten",name_en="Geburten",
description_de="Geburten",description_fr="Geburten",
description_it="Geburten",description_en="Geburten",
unit_short_de="Pers.",unit_short_fr="Pers.",unit_short_it="Pers.",unit_short_en="Pers.",
unit_long_de="Personen",unit_long_fr="Personen",unit_long_it="Personen",unit_long_en="Personen",
source="BFS-BEVNAT",dim1_id=1,dim2_id=2,dim3_id=4,dim4_id=NA,last_updated=NA,min_year=1969,max_year=2020)
statbot_ind_32001<-data.frame(indicator_id=32001,name_de="Fläche",name_fr="Fläche",
name_it="Fläche",name_en="Fläche",
description_de="Fläche",description_fr="Fläche",
description_it="Fläche",description_en="Fläche",
unit_short_de="km2",unit_short_fr="km2",unit_short_it="km2",unit_short_en="km2",
unit_long_de="km2",unit_long_fr="km2",unit_long_it="km2",unit_long_en="km2",
source="BFS-Gemeindeporträt",dim1_id=NA,dim2_id=NA,dim3_id=NA,dim4_id=NA,last_updated=NA,min_year=2016,max_year=2018)
statbot_ind_12001<-data.frame(indicator_id=12001,name_de="Beschäftigte",name_fr="Beschäftigte",
name_it="Beschäftigte",name_en="Beschäftigte",
description_de="Beschäftigte",description_fr="Beschäftigte",
description_it="Beschäftigte",description_en="Beschäftigte",
unit_short_de="Pers.",unit_short_fr="Pers.",unit_short_it="Pers.",unit_short_en="Pers.",
unit_long_de="Personen",unit_long_fr="Personen",unit_long_it="Personen",unit_long_en="Personen",
source="BFS-STATENT",dim1_id=1,dim2_id=5,dim3_id=NA,dim4_id=NA,last_updated=NA,min_year=2011,max_year=2018)
statbot_ind_12002<-data.frame(indicator_id=12002,name_de="Beschäftigte pro 1000 Einwohner",name_fr="Beschäftigte pro 1000 Einwohner",
name_it="Beschäftigte pro 1000 Einwohner",name_en="Beschäftigte pro 1000 Einwohner",
description_de="Beschäftigte pro 1000 Einwohner",description_fr="Beschäftigte pro 1000 Einwohner",
description_it="Beschäftigte pro 1000 Einwohner",description_en="Beschäftigte pro 1000 Einwohner",
unit_short_de="Pers./1000 Einw.",unit_short_fr="Pers./1000 Einw.",unit_short_it="Pers./1000 Einw.",unit_short_en="Pers./1000 Einw.",
unit_long_de="Personen pro 1000 Einwohner",unit_long_fr="Personen pro 1000 Einwohner",unit_long_it="Personen pro 1000 Einwohner",unit_long_en="Personen pro 1000 Einwohner",
source="BFS-STATENT",dim1_id=1,dim2_id=5,dim3_id=NA,dim4_id=NA,last_updated=NA,min_year=2011,max_year=2018)
statbot_ind_12101<-data.frame(indicator_id=12101,name_de="Vollzeitäquivalente",name_fr="Vollzeitäquivalente",
name_it="Vollzeitäquivalente",name_en="Vollzeitäquivalente",
description_de="Vollzeitäquivalente",description_fr="Vollzeitäquivalente",
description_it="Vollzeitäquivalente",description_en="Vollzeitäquivalente",
unit_short_de="VZÄ",unit_short_fr="VZÄ",unit_short_it="VZÄ",unit_short_en="VZÄ",
unit_long_de="Vollzeitäquivalente",unit_long_fr="Vollzeitäquivalente",unit_long_it="Vollzeitäquivalente",unit_long_en="Vollzeitäquivalente",
source="BFS-STATENT",dim1_id=1,dim2_id=5,dim3_id=NA,dim4_id=NA,last_updated=NA,min_year=2015,max_year=2018)
statbot_ind_12102<-data.frame(indicator_id=12102,name_de="Vollzeitäquivalente pro 1000 Einwohner",name_fr="Vollzeitäquivalente pro 1000 Einwohner",
name_it="Vollzeitäquivalente pro 1000 Einwohner",name_en="Vollzeitäquivalente pro 1000 Einwohner",
description_de="Vollzeitäquivalente pro 1000 Einwohner",description_fr="Vollzeitäquivalente pro 1000 Einwohner",
description_it="Vollzeitäquivalente pro 1000 Einwohner",description_en="Vollzeitäquivalente pro 1000 Einwohner",
unit_short_de="VZÄ/1000 Einw.",unit_short_fr="VZÄ/1000 Einw.",unit_short_it="VZÄ/1000 Einw.",unit_short_en="VZÄ/1000 Einw.",
unit_long_de="Vollzeitäquivalente pro 1000 Einwohner",unit_long_fr="Vollzeitäquivalente pro 1000 Einwohner",unit_long_it="Vollzeitäquivalente pro 1000 Einwohner",unit_long_en="Vollzeitäquivalente pro 1000 Einwohner",
source="BFS-STATENT",dim1_id=1,dim2_id=5,dim3_id=NA,dim4_id=NA,last_updated=NA,min_year=2015,max_year=2018)
statbot_ind_23001<-data.frame(indicator_id=23001,name_de="Arbeitsstätten",name_fr="Arbeitsstätten",
name_it="Arbeitsstätten",name_en="Arbeitsstätten",
description_de="Arbeitsstätten",description_fr="Arbeitsstätten",
description_it="Arbeitsstätten",description_en="Arbeitsstätten",
unit_short_de="Arbeitsstätten",unit_short_fr="Arbeitsstätten",unit_short_it="Arbeitsstätten",unit_short_en="Arbeitsstätten",
unit_long_de="Arbeitsstätten",unit_long_fr="Arbeitsstätten",unit_long_it="Arbeitsstätten",unit_long_en="Arbeitsstätten",
source="BFS-STATENT",dim1_id=5,dim2_id=NA,dim3_id=NA,dim4_id=NA,last_updated=NA,min_year=2011,max_year=2018)
statbot_ind_23002<-data.frame(indicator_id=23002,name_de="Arbeitsstätten pro 1000 Einwohner",name_fr="Arbeitsstätten pro 1000 Einwohner",
name_it="Arbeitsstätten pro 1000 Einwohner",name_en="Arbeitsstätten pro 1000 Einwohner",
description_de="Arbeitsstätten pro 1000 Einwohner",description_fr="Arbeitsstätten pro 1000 Einwohner",
description_it="Arbeitsstätten pro 1000 Einwohner",description_en="Arbeitsstätten pro 1000 Einwohner",
unit_short_de="Arbeitsstätten pro 1000 Einwohner",unit_short_fr="Arbeitsstätten pro 1000 Einwohner",unit_short_it="Arbeitsstätten pro 1000 Einwohner",unit_short_en="Arbeitsstätten pro 1000 Einwohner",
unit_long_de="Arbeitsstätten pro 1000 Einwohner",unit_long_fr="Arbeitsstätten pro 1000 Einwohner",unit_long_it="Arbeitsstätten pro 1000 Einwohner",unit_long_en="Arbeitsstätten pro 1000 Einwohner",
source="BFS-STATENT",dim1_id=5,dim2_id=NA,dim3_id=NA,dim4_id=NA,last_updated=NA,min_year=2011,max_year=2018)
# merge all the variables starting with statbot_ind_ together
# and before that also fill all the empty dimensions with NAs if not defined before
out<-NULL
for(i in ls(pat="statbot_ind_")){
temp<-eval(as.name(i))
temp<-fill_dimensions_with_na(temp)
out<-rbind(out,temp)
}
# reorder
out<- out[,c("indicator_id","name_de","name_fr","name_it","name_en",
"description_de","description_fr","description_it","description_en","unit_short_de",
"unit_short_fr","unit_short_it","unit_short_en","unit_long_de","unit_long_fr",
"unit_long_it","unit_long_en","source","dim1_id","dim2_id","dim3_id","dim4_id",
"dim5_id","dim6_id","min_year","max_year","last_updated")]
# output
write.csv(out,"data/indicators.csv",row.names = F)
# Main-Script - see also readme
# preparation of some global constants
src_folder<-"src/"
log_folder<-"log/"
datetime<-format(Sys.time(), "%Y-%m-%d_%H-%M")
flag_force_update<-TRUE
# temporary work_around
source("statbot_read_px.R")
# function to quicker log some output
logger<-function(log_string){
cat(log_string,sep = "\n",file=paste0(log_folder,"main_",datetime,".log"),append=TRUE)
}
# get the name of all the files in the src-folder
logger("STARTING STATBOT DATA MANAGEMENT...")
logger("LOADING SRC FILES...")
files.sources<-paste0(src_folder,list.files(src_folder))
# separate R and python scripts
logger("SEPARATING SRC FILES...")
r.sources<-NULL
python.sources<-NULL
for(i in files.sources){
if(substr(i,nchar(i)-1,nchar(i))==".R"){
r.sources<-c(r.sources,i)
}else{
if(substr(i,nchar(i)-2,nchar(i))==".py"){
python.sources<-c(python.sources,i)}
else{
logger("Error: Some Files are neither .R nor .py")
stop("Stopping the execution")
}
}
}
# Cleaning/Removing all the previous R-functions starting with statbot_src_ in case that they are still in memory
rm(list=ls(pat="statbot_src_"))
# source all the R-files
sapply(r.sources, source)
source("init_scripts/create_spatial_units_v2.R")
create_spatial_units()
# R-loop: execute all sourced functions statbot_src_XXX
logger("STARTING R-LOOP...")
for(i in lsf.str()){
start_time<-Sys.time()
if(substr(i,1,12)=="statbot_src_"){
print(paste0("Executing script... ",i))
return_value<-tryCatch(do.call(i,args=list(flag_force_update=flag_force_update)),
error=function(c) paste0("error loading r-script: ",c),
warning=function(c) paste0("warning loading r-script: ",c),
message=function(c) paste0("message loading r-script: ",c))
end_time<-Sys.time()
logger(paste0(
substr(i,13,nchar(i)),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
}
# python-loop: execute all sourced python files directly
logger("STARTING PYTHON-LOOP...")
for(i in python.sources){
start_time<-Sys.time()
print(paste0("Executing script... ",i))
return_value<-tryCatch(system(paste0("python ",i)),
error=function(c) paste0("error loading python-script: ",c),
warning=function(c) paste0("warning loading python-script: ",c),
message=function(c) paste0("message loading python-script: ",c))
#TODO: THE PYTHON PART STILL NEEDS A UP-TO-DATE CODE AND HASH-TEST
return_value<-ifelse(return_value==0,"UPDATE OK","ERROR")
end_time<-Sys.time()
logger(paste0(
substr(i,as.integer(gregexpr(pattern ='/',i)[[1]])+1,nchar(i)-3),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
logger("FINISHED MAIN-SCRIPT.")
destfile<-"temp/bfs_2300X_1200X_1210X.px"
download.file("https://www.bfs.admin.ch/bfsstatic/dam/assets/13787332/master",destfile=destfile)
df<-statbot_read.px(destfile)
df<-as.data.frame(df)
df$temp<-stringr::str_locate(pattern =' ',df$Gemeinde)[,1]
df$spatialunit_id<-ifelse(is.na(df$temp),0,as.numeric(substr(df$Gemeinde,0,df$temp)))
#If you want to have a list of all Swiss communes, then do the following
#ch<-unique(df[df$spatialunit_id!=0,c("spatialunit_id","Gemeinde","temp")])
#ch$Gemeinde<-substr(ch$Gemeinde,ch$temp,length(ch$Gemeinde))
#write.csv(ch[,c("spatialunit_id","Gemeinde")],"data/ch_gemeinden.csv",row.names = F)
# Beschäftigte
df$temp<-stringr::str_locate(pattern ='Beschäftigte',df$Beobachtungseinheit)[,1]
sub_df<-df[!is.na(df$temp),]
sub_df<-sub_df %>% mutate(dim1_value_id = case_when(Beobachtungseinheit=="Beschäftigte"~0,
Beobachtungseinheit=="Beschäftigte Männer"~1,
Beobachtungseinheit=="Beschäftigte Frauen"~2),
dim2_value_id = case_when(Wirtschaftssektor=="Wirtschaftssektor - Total"~0,
Wirtschaftssektor=="Primärsektor"~1,
Wirtschaftssektor=="Sekundärer Sektor"~2,
Wirtschaftssektor=="Tertiärer Sektor"~3))
sub_df$indicator_id<-12001
sub_df$timeinfo_id<-1
sub_df$dim1_value_id<-1
sub_df$dim2_value_id<-5
sub_df<-fill_dimensions_with_na(sub_df,value_id=TRUE)
colnames(sub_df)[colnames(sub_df)=="Jahr"]<-"time_value"
sub_df<-bring_indicator_values_to_order(sub_df[,global_total_list],final_length=T)
head(sub_df)
length(GLOBAL_TOTAL_LIST)
length(sub_df)
names(sub_df)
df<-sub_df
list_to_select<-GLOBAL_TOTAL_LIST[GLOBAL_TOTAL_LIST %in% names(df)]
list_to_select
if(final_length&length(list_to_select)!=length(GLOBAL_TOTAL_LIST)) stop(paste0("Error: Amount of cols incorrect: ",length(list_to_select)," instead of ",length(GLOBAL_TOTAL_LIST),"."))
final_length=T
if(final_length&length(list_to_select)!=length(GLOBAL_TOTAL_LIST)) stop(paste0("Error: Amount of cols incorrect: ",length(list_to_select)," instead of ",length(GLOBAL_TOTAL_LIST),"."))
GLOBAL_TOTAL_LIST<-c("indicator_id","spatialunit_id","time_value","timeinfo_id",
"value")
for(i in 1:GLOBAL_MAX_DIM) GLOBAL_TOTAL_LIST<-c(GLOBAL_TOTAL_LIST,paste0("dim",i,"_value_id"))
bring_indicator_values_to_order<-function(df, final_length=F){
if(sum(names(df) %in% GLOBAL_TOTAL_LIST)<length(names(df))) stop("Error: invalid var-name(s)")
list_to_select<-GLOBAL_TOTAL_LIST[GLOBAL_TOTAL_LIST %in% names(df)]
if(final_length&length(list_to_select)!=length(GLOBAL_TOTAL_LIST)) stop(paste0("Error: Amount of cols incorrect: ",length(list_to_select)," instead of ",length(GLOBAL_TOTAL_LIST),"."))
if(length(list_to_select)<length(GLOBAL_TOTAL_LIST)) print("Info: Subset selected")
return(df[,list_to_select])
}
sub_df<-bring_indicator_values_to_order(sub_df[,GLOBAL_TOTAL_LIST],final_length=T)
sub_df<-zh_add_regions_bezirke(sub_df)
sub_df<-bring_indicator_values_to_order(sub_df[,GLOBAL_TOTAL_LIST],final_length=T)
# Main-Script - see also readme
# preparation of some global constants
src_folder<-"src/"
log_folder<-"log/"
datetime<-format(Sys.time(), "%Y-%m-%d_%H-%M")
flag_force_update<-TRUE
# temporary work_around
source("statbot_read_px.R")
# function to quicker log some output
logger<-function(log_string){
cat(log_string,sep = "\n",file=paste0(log_folder,"main_",datetime,".log"),append=TRUE)
}
# get the name of all the files in the src-folder
logger("STARTING STATBOT DATA MANAGEMENT...")
logger("LOADING SRC FILES...")
files.sources<-paste0(src_folder,list.files(src_folder))
# separate R and python scripts
logger("SEPARATING SRC FILES...")
r.sources<-NULL
python.sources<-NULL
for(i in files.sources){
if(substr(i,nchar(i)-1,nchar(i))==".R"){
r.sources<-c(r.sources,i)
}else{
if(substr(i,nchar(i)-2,nchar(i))==".py"){
python.sources<-c(python.sources,i)}
else{
logger("Error: Some Files are neither .R nor .py")
stop("Stopping the execution")
}
}
}
# Cleaning/Removing all the previous R-functions starting with statbot_src_ in case that they are still in memory
rm(list=ls(pat="statbot_src_"))
# source all the R-files
sapply(r.sources, source)
source("init_scripts/create_spatial_units_v2.R")
create_spatial_units()
# R-loop: execute all sourced functions statbot_src_XXX
logger("STARTING R-LOOP...")
for(i in lsf.str()){
start_time<-Sys.time()
if(substr(i,1,12)=="statbot_src_"){
print(paste0("Executing script... ",i))
return_value<-tryCatch(do.call(i,args=list(flag_force_update=flag_force_update)),
error=function(c) paste0("error loading r-script: ",c),
warning=function(c) paste0("warning loading r-script: ",c),
message=function(c) paste0("message loading r-script: ",c))
end_time<-Sys.time()
logger(paste0(
substr(i,13,nchar(i)),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
}
# python-loop: execute all sourced python files directly
logger("STARTING PYTHON-LOOP...")
for(i in python.sources){
start_time<-Sys.time()
print(paste0("Executing script... ",i))
return_value<-tryCatch(system(paste0("python ",i)),
error=function(c) paste0("error loading python-script: ",c),
warning=function(c) paste0("warning loading python-script: ",c),
message=function(c) paste0("message loading python-script: ",c))
#TODO: THE PYTHON PART STILL NEEDS A UP-TO-DATE CODE AND HASH-TEST
return_value<-ifelse(return_value==0,"UPDATE OK","ERROR")
end_time<-Sys.time()
logger(paste0(
substr(i,as.integer(gregexpr(pattern ='/',i)[[1]])+1,nchar(i)-3),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
logger("FINISHED MAIN-SCRIPT.")
# Main-Script - see also readme
# preparation of some global constants
src_folder<-"src/"
log_folder<-"log/"
datetime<-format(Sys.time(), "%Y-%m-%d_%H-%M")
flag_force_update<-TRUE
# temporary work_around
source("statbot_read_px.R")
# function to quicker log some output
logger<-function(log_string){
cat(log_string,sep = "\n",file=paste0(log_folder,"main_",datetime,".log"),append=TRUE)
}
# get the name of all the files in the src-folder
logger("STARTING STATBOT DATA MANAGEMENT...")
logger("LOADING SRC FILES...")
files.sources<-paste0(src_folder,list.files(src_folder))
# separate R and python scripts
logger("SEPARATING SRC FILES...")
r.sources<-NULL
python.sources<-NULL
for(i in files.sources){
if(substr(i,nchar(i)-1,nchar(i))==".R"){
r.sources<-c(r.sources,i)
}else{
if(substr(i,nchar(i)-2,nchar(i))==".py"){
python.sources<-c(python.sources,i)}
else{
logger("Error: Some Files are neither .R nor .py")
stop("Stopping the execution")
}
}
}
# Cleaning/Removing all the previous R-functions starting with statbot_src_ in case that they are still in memory
rm(list=ls(pat="statbot_src_"))
# source all the R-files
sapply(r.sources, source)
source("init_scripts/create_spatial_units_v2.R")
create_spatial_units()
# R-loop: execute all sourced functions statbot_src_XXX
logger("STARTING R-LOOP...")
for(i in lsf.str()){
start_time<-Sys.time()
if(substr(i,1,12)=="statbot_src_"){
print(paste0("Executing script... ",i))
return_value<-tryCatch(do.call(i,args=list(flag_force_update=flag_force_update)),
error=function(c) paste0("error loading r-script: ",c),
warning=function(c) paste0("warning loading r-script: ",c),
message=function(c) paste0("message loading r-script: ",c))
end_time<-Sys.time()
logger(paste0(
substr(i,13,nchar(i)),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
}
# python-loop: execute all sourced python files directly
logger("STARTING PYTHON-LOOP...")
for(i in python.sources){
start_time<-Sys.time()
print(paste0("Executing script... ",i))
return_value<-tryCatch(system(paste0("python ",i)),
error=function(c) paste0("error loading python-script: ",c),
warning=function(c) paste0("warning loading python-script: ",c),
message=function(c) paste0("message loading python-script: ",c))
#TODO: THE PYTHON PART STILL NEEDS A UP-TO-DATE CODE AND HASH-TEST
return_value<-ifelse(return_value==0,"UPDATE OK","ERROR")
end_time<-Sys.time()
logger(paste0(
substr(i,as.integer(gregexpr(pattern ='/',i)[[1]])+1,nchar(i)-3),
": ",
return_value,
paste0(" FINISHED IN: ",round(as.numeric (end_time - start_time, units = "secs"),1), " SECONDS")
))
}
logger("FINISHED MAIN-SCRIPT.")
